package at.sparklingscience.urbantrees.security;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.security.crypto.encrypt.Encryptors;
import org.springframework.security.crypto.encrypt.TextEncryptor;
import org.springframework.security.crypto.keygen.KeyGenerators;
import org.springframework.security.crypto.keygen.StringKeyGenerator;

import at.sparklingscience.urbantrees.security.user.AuthenticationService;

/**
 * (Non-static) Helper class for easy string encryption and decryption.
 * 
 * Reference: https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/crypto.html
 * 
 * Note: This class is separated into two parts to keep crypto-relevant code easy to understand.
 * 		 The rest of the class is used to upgrade encryption from older versions.
 * 
 * @author Laurenz Fiala
 * @since 2019/07/20
 */
public class CryptoHelper {
	
	@Value("${at.sparklingscience.urbantrees.encryptionPassword}")
	private String encryptionPassword;
	
	@Autowired
	private AuthenticationService authService;
	
	/**
	 * Separates the 4 parts of the final composite encrypted string.
	 */
	private static final String PART_SEPARATOR = "/";
	
	/**
	 * Encryption version is appended to the encrypted data.
	 * Only use this format: VERSIONCODE_DATE (VERSIONCODE is integer, Date is YYYYMMDD)
	 * 
	 * Note: "/" must not be part of this version string.
	 * 
	 * Impl Note: This is used to upgrade encryption later if it needs to be improved.
	 * 
	 * @see CryptoHelper#getCompositeEncryptionString(String, String, String)
	 */
	private static final String VERSION = "1_20190720";

	// methods available in crptohelper
	private static final String METHOD_NONQUERYABLE = "a";
	private static final String METHOD_QUERYABLE = "q";
	
	/**
	 * Spring cryptos' StringKeyGenerator which already has the
	 * convenience encryption methods.
	 * Is thread-safe. Ref: https://docs.spring.io/spring-security/site/docs/5.0.x/reference/html/crypto.html#spring-security-crypto-keygenerators
	 */
	private StringKeyGenerator stringKeyGenerator = KeyGenerators.string();

	/**
	 * Encrypts given string using AES256/CBC/PKCS5Padding using random salt and
	 * application-global password.
	 * @param data
	 * @return Composite string which contains encrypted data, salt and encryption version
	 * 		   and can be stored in DB.
	 * 		   Layout: "encryptedData/salt/version"
	 */
	public String encrypt(String data) {
		
		final String salt = this.stringKeyGenerator.generateKey();
		final TextEncryptor encryptor = Encryptors.text(this.encryptionPassword, salt);
		final String encryptedData = encryptor.encrypt(data);
		
		return this.getCompositeEncryptionString(encryptedData, salt, VERSION, METHOD_NONQUERYABLE);
		
	}
	
	/**
	 * Encrypts given string using AES256/CBC/PKCS5Padding using salt stored in auth settings table and
	 * application-global password.
	 * @param data
	 * @return Composite string which contains encrypted data, salt and encryption version
	 * 		   and can be stored in DB.
	 * 		   Layout: "encryptedData/salt/version/q"
	 */
	public String encryptQueryable(String data) {
		
		final String salt = this.authService.getQueryableEncryptionSalt();
		final TextEncryptor encryptor = Encryptors.queryableText(this.encryptionPassword, salt);
		final String encryptedData = encryptor.encrypt(data);
		
		return this.getCompositeEncryptionString(encryptedData, salt, VERSION, METHOD_QUERYABLE);
		
	}
	
	/**
	 * Decrypts the given string (previously generated by
	 * {@link #encrypt(String)} or {@link #encryptQueryable(String)}.
	 * Encrypt also stores the used method, so separate decryption
	 * implementations are not neccessary.
	 * @param compositeEncryptedString output of {@link #encrypt(String)}
	 * 								   or {@link #encryptQueryable(String)}
	 * @return Decrypted plaintext string (without meta information stored
	 * 		   for decyrption)
	 */
	public String decrypt(String compositeEncryptedString) {
		
		final String[] parts = compositeEncryptedString.split("/", 4);
		if (parts.length != 4) {
			throw new RuntimeException("Text to decrypt is of illegal format! Illegal input: " + compositeEncryptedString);
		}
		
		final String encryptedData = parts[0];
		final String salt = parts[1];
		//final String version = parts[2];
		final String method = parts[3];
		
		final TextEncryptor encryptor;
		switch (method) {
		
		case METHOD_NONQUERYABLE:
			encryptor = Encryptors.text(this.encryptionPassword, salt);
			break;
			
		case METHOD_QUERYABLE:
			encryptor = Encryptors.queryableText(this.encryptionPassword, salt);
			break;

		default:
			throw new RuntimeException("Invalid decryption method found: " + method + " in input " + compositeEncryptedString);
		
		}
		
		return encryptor.decrypt(encryptedData);
		
	}
	
	private String getCompositeEncryptionString(final String encryptedData, final String salt, final String version, final String method) {
		return 
				encryptedData + PART_SEPARATOR +
				salt + PART_SEPARATOR +
				version + PART_SEPARATOR +
				method;
	}
	
}
